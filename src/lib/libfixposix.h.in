/*******************************************************************************/
/* Permission is hereby granted, free of charge, to any person or organization */
/* obtaining a copy of the software and accompanying documentation covered by  */
/* this license (the "Software") to use, reproduce, display, distribute,       */
/* execute, and transmit the Software, and to prepare derivative works of the  */
/* Software, and to permit third-parties to whom the Software is furnished to  */
/* do so, all subject to the following:                                        */
/*                                                                             */
/* The copyright notices in the Software and this entire statement, including  */
/* the above license grant, this restriction and the following disclaimer,     */
/* must be included in all copies of the Software, in whole or in part, and    */
/* all derivative works of the Software, unless such copies or derivative      */
/* works are solely in the form of machine-executable object code generated by */
/* a source language processor.                                                */
/*                                                                             */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  */
/* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,    */
/* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT   */
/* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE   */
/* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, */
/* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER */
/* DEALINGS IN THE SOFTWARE.                                                   */
/*******************************************************************************/

#pragma once

#if defined(__cplusplus)
// C++ doesn't have restricted pointers (yet)
# define restrict
extern "C" {
#endif

#include <stdlib.h>
#include <stdbool.h>

int lfp_mkstemp(char *tmplate);



#include <errno.h>

#define EBUG 10000



int lfp_strerror(int errnum, char *buf, size_t buflen);

size_t lfp_strnlen(const char *s, size_t maxlen);



#include <inttypes.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

extern char **environ;

#if !defined(O_CLOEXEC)
// Syscalls use "int" for passing flags, and since
// *nix systems use the LP64 data model, "int" is 32 bits
// which means that we can allocate unsupported flags in the
// upper part of an uint64_t value
# define O_CLOEXEC ( 1ULL << 32 )
#endif

int lfp_open(const char *pathname, uint64_t flags, ...);

int lfp_creat(const char *pathname, mode_t mode);

int lfp_pipe(int pipefd[2], uint64_t flags);

int lfp_is_fd_cloexec(int fd);

int lfp_set_fd_cloexec(int fd, bool enabled);

int lfp_is_fd_nonblock(int fd);

int lfp_set_fd_nonblock(int fd, bool enabled);

int lfp_truncate(const char *path, off_t length);

int lfp_ftruncate(int fd, off_t length);

ssize_t lfp_pread(int fd, void *buf, size_t count, off_t offset);

ssize_t lfp_pwrite(int fd, const void *buf, size_t count, off_t offset);

off_t lfp_lseek(int fd, off_t offset, int whence);

int lfp_stat(const char *path, struct stat *buf);

int lfp_fstat(int fd, struct stat *buf);

int lfp_lstat(const char *path, struct stat *buf);

int lfp_fd_is_open(int fd);

bool lfp_isreg(mode_t mode);

bool lfp_isdir(mode_t mode);

bool lfp_ischr(mode_t mode);

bool lfp_isblk(mode_t mode);

bool lfp_isfifo(mode_t mode);

bool lfp_islnk(mode_t mode);

bool lfp_issock(mode_t mode);

char* lfp_getpath(char *const envp[]);

int lfp_execve(const char *path, char *const argv[], char *const envp[])
    __attribute__((nonnull (1)));

int lfp_execvpe(const char *file, char *const argv[], char *const envp[])
    __attribute__((nonnull (1)));



#include <sys/mman.h>

void *lfp_mmap(void *addr, size_t length, int prot,
               int flags, int fd, off_t offset);

int lfp_munmap(void *addr, size_t length);



#include <sys/select.h>

int lfp_select(int nfds, fd_set *readfds, fd_set *writefds,
               fd_set *exceptfds, const struct timespec *timeout,
               const sigset_t *sigmask);

void lfp_fd_clr(int fd, fd_set *set);

bool lfp_fd_isset(int fd, fd_set *set);

void lfp_fd_set(int fd, fd_set *set);

void lfp_fd_zero(fd_set *set);



#include <sys/socket.h>

int lfp_socket(int domain, int type, int protocol, uint64_t flags);

int lfp_accept(int             sockfd,
               struct sockaddr *addr,
               socklen_t       *addrlen,
               uint64_t        flags);

struct cmsghdr* lfp_cmsg_firsthdr(struct msghdr* msgh);

struct cmsghdr* lfp_cmsg_nxthdr(struct msghdr* msgh, struct cmsghdr* cmsg);

size_t lfp_cmsg_space(size_t length);

size_t lfp_cmsg_len(size_t length);

void* lfp_cmsg_data(struct cmsghdr* cmsg);



#include <errno.h>

int lfp_errno(void);

int lfp_set_errno(int value);



#include <sys/wait.h>

bool lfp_wifexited(int status);

int lfp_wexitstatus(int status);

bool lfp_wifsignaled(int status);

int lfp_wtermsig(int status);

bool lfp_wcoredump(int status);

bool lfp_wifstopped(int status);

int lfp_wstopsig(int status);

bool lfp_wifcontinued(int status);



typedef struct {
    int initialized;
    int allocated;
    struct lfp_spawn_action *actions;
} lfp_spawn_file_actions_t;

int lfp_spawn_file_actions_init(lfp_spawn_file_actions_t *file_actions);

int lfp_spawn_file_actions_destroy(lfp_spawn_file_actions_t *file_actions);

int lfp_spawn_file_actions_addopen(lfp_spawn_file_actions_t *file_actions,
                                   int fd, const char *path,
                                   uint64_t oflags, mode_t mode);

int lfp_spawn_file_actions_addclose(lfp_spawn_file_actions_t *file_actions,
                                    int fd);

int lfp_spawn_file_actions_adddup2(lfp_spawn_file_actions_t *file_actions,
                                   int fd, int newfd);

typedef struct {
    uint32_t flags;
    sigset_t sigdefault;
    sigset_t sigmask;
    pid_t    pgroup;
    uid_t    uid;
    gid_t    gid;
} lfp_spawnattr_t;

typedef enum {
        LFP_SPAWN_SETSIGMASK    = 1 << 0,
#define LFP_SPAWN_SETSIGMASK    ( 1 << 0 )
        LFP_SPAWN_SETSIGDEFAULT = 1 << 1,
#define LFP_SPAWN_SETSIGDEFAULT ( 1 << 1 )
        LFP_SPAWN_SETPGROUP     = 1 << 2,
#define LFP_SPAWN_SETPGROUP     ( 1 << 2 )
        LFP_SPAWN_RESETIDS      = 1 << 3,
#define LFP_SPAWN_RESETIDS      ( 1 << 3 )
        LFP_SPAWN_SETUID        = 1 << 4,
#define LFP_SPAWN_SETUID        ( 1 << 4 )
        LFP_SPAWN_SETGID        = 1 << 5
#define LFP_SPAWN_SETGID        ( 1 << 5 )
} lfp_spawnattr_flags;

int lfp_spawnattr_init(lfp_spawnattr_t *attr);
int lfp_spawnattr_destroy(lfp_spawnattr_t *attr);

int lfp_spawnattr_getflags(lfp_spawnattr_t *attr, uint32_t *flags);
int lfp_spawnattr_setflags(lfp_spawnattr_t *attr, const uint32_t flags);

int lfp_spawnattr_getsigmask(lfp_spawnattr_t *attr, sigset_t *sigmask);
int lfp_spawnattr_setsigmask(lfp_spawnattr_t *attr, const sigset_t *sigmask);

int lfp_spawnattr_getsigdefault(lfp_spawnattr_t *attr, sigset_t *sigdefault);
int lfp_spawnattr_setsigdefault(lfp_spawnattr_t *attr, const sigset_t *sigdefault);

int lfp_spawnattr_getpgroup(lfp_spawnattr_t *attr, pid_t *pgroup);
int lfp_spawnattr_setpgroup(lfp_spawnattr_t *attr, const pid_t pgroup);

int lfp_spawnattr_getuid(lfp_spawnattr_t *attr, uid_t *uid);
int lfp_spawnattr_setuid(lfp_spawnattr_t *attr, const uid_t uid);

int lfp_spawnattr_getgid(lfp_spawnattr_t *attr, gid_t *gid);
int lfp_spawnattr_setgid(lfp_spawnattr_t *attr, const gid_t gid);

int lfp_spawn(pid_t *restrict pid,
              const char *restrict path,
              char *const argv[restrict],
              char *const envp[restrict],
              const lfp_spawn_file_actions_t *restrict file_actions,
              const lfp_spawnattr_t *restrict attr);

int lfp_spawnp(pid_t *restrict pid,
               const char *restrict file,
               char *const argv[restrict],
               char *const envp[restrict],
               const lfp_spawn_file_actions_t *restrict file_actions,
               const lfp_spawnattr_t *restrict attr);



#include <signal.h>

typedef void (*lfp_sighandler_t) (int);

lfp_sighandler_t lfp_sig_dfl(void);

lfp_sighandler_t lfp_sig_err(void);

lfp_sighandler_t lfp_sig_hold(void);

lfp_sighandler_t lfp_sig_ign(void);

// FIXME: inline NSIG
// NSIG is nowhere in POSIX, so some systems might not have it
// Linux and FreeBSD do, and that's enough for the moment
#if defined(NSIG)
#define LFP_NSIG NSIG
#else
# error "Cannot determine number of signals"
#endif

int lfp_sigrtmin(void);

int lfp_sigrtmax(void);



#if defined(__linux__)
# if @HAVE_EMULATED_SIGNALFD@ // HAVE_EMULATED_SIGNALFD
struct signalfd_siginfo { unsigned int ssi_signo; };
# else
#  include <sys/signalfd.h>
# endif
#endif

int lfp_install_signalfd(int signum, int sa_flags, bool* blockp);

int lfp_uninstall_signalfd(int signum, bool block);



#include <dirent.h>

int lfp_readdir(DIR *dirp, struct dirent *entry, struct dirent **result);



#include <time.h>

// FIXME: need to check that sizeof(clockid_t) <= 32
typedef uint64_t lfp_clockid_t;

#if !defined(_POSIX_TIMERS)
# define CLOCK_REALTIME  0
# define CLOCK_MONOTONIC 1
#elif !defined(_POSIX_MONOTONIC_CLOCK)
# define CLOCK_MONOTONIC (1 << 32)
#endif

int lfp_clock_getres(lfp_clockid_t clk_id, struct timespec *res);

int lfp_clock_gettime(lfp_clockid_t clk_id, struct timespec *tp);

int lfp_clock_settime(lfp_clockid_t clk_id, struct timespec *tp);



#include <sys/resource.h>

int lfp_getrlimit(int resource, struct rlimit *rlim);

int lfp_setrlimit(int resource, const struct rlimit *rlim);

#if defined(__cplusplus)
}
#endif
