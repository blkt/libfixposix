#if !defined(_LIBFIXPOSIX_H_)
# define _LIBFIXPOSIX_H_

// FIXME: this is a kludge meant to ensure that
// this library and programs using it are build with the
// same CFLAGS, but it should be replaced with something
// like pkgconfig
#if defined(__linux__)
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE 600
# undef _LARGEFILE_SOURCE
# define _LARGEFILE_SOURCE
# undef _FILE_OFFSET_BITS
# define _FILE_OFFSET_BITS 64
# undef _GNU_SOURCE
# define _GNU_SOURCE
#endif

#include <stdlib.h>
#include <stdbool.h>



#include <errno.h>

typedef enum {
    LFP_E2BIG           = E2BIG,
    LFP_EACCES          = EACCES,
    LFP_EADDRINUSE      = EADDRINUSE,
    LFP_EADDRNOTAVAIL   = EADDRNOTAVAIL,
    LFP_EAFNOSUPPORT    = EAFNOSUPPORT,
    LFP_EAGAIN          = EAGAIN,
    LFP_EALREADY        = EALREADY,
    LFP_EBADF           = EBADF,
    LFP_EBADMSG         = EBADMSG,
    LFP_EBUSY           = EBUSY,
    LFP_ECANCELED       = ECANCELED,
    LFP_ECHILD          = ECHILD,
    LFP_ECONNABORTED    = ECONNABORTED,
    LFP_ECONNREFUSED    = ECONNREFUSED,
    LFP_ECONNRESET      = ECONNRESET,
    LFP_EDEADLK         = EDEADLK,
    LFP_EDESTADDRREQ    = EDESTADDRREQ,
    LFP_EDOM            = EDOM,
    LFP_EDQUOT          = EDQUOT,
    LFP_EEXIST          = EEXIST,
    LFP_EFAULT          = EFAULT,
    LFP_EFBIG           = EFBIG,
#if defined(EHOSTDOWN)
    LFP_EHOSTDOWN       = EHOSTDOWN,
#endif
    LFP_EHOSTUNREACH    = EHOSTUNREACH,
    LFP_EIDRM           = EIDRM,
    LFP_EILSEQ          = EILSEQ,
    LFP_EINPROGRESS     = EINPROGRESS,
    LFP_EINTR           = EINTR,
    LFP_EINVAL          = EINVAL,
    LFP_EIO             = EIO,
    LFP_EISCONN         = EISCONN,
    LFP_EISDIR          = EISDIR,
    LFP_ELOOP           = ELOOP,
    LFP_EMFILE          = EMFILE,
    LFP_EMLINK          = EMLINK,
    LFP_EMSGSIZE        = EMSGSIZE,
    LFP_EMULTIHOP       = EMULTIHOP,
    LFP_ENAMETOOLONG    = ENAMETOOLONG,
    LFP_ENETDOWN        = ENETDOWN,
    LFP_ENETRESET       = ENETRESET,
    LFP_ENETUNREACH     = ENETUNREACH,
    LFP_ENFILE          = ENFILE,
    LFP_ENOBUFS         = ENOBUFS,
    LFP_ENODATA         = ENODATA,
    LFP_ENODEV          = ENODEV,
    LFP_ENOENT          = ENOENT,
    LFP_ENOEXEC         = ENOEXEC,
    LFP_ENOLCK          = ENOLCK,
    LFP_ENOLINK         = ENOLINK,
    LFP_ENOMEM          = ENOMEM,
    LFP_ENOMSG          = ENOMSG,
#if defined(ENONET)
    LFP_ENONET          = ENONET,
#endif
    LFP_ENOPROTOOPT     = ENOPROTOOPT,
    LFP_ENOSPC          = ENOSPC,
    LFP_ENOSR           = ENOSR,
    LFP_ENOSTR          = ENOSTR,
    LFP_ENOSYS          = ENOSYS,
    LFP_ENOTCONN        = ENOTCONN,
    LFP_ENOTDIR         = ENOTDIR,
    LFP_ENOTEMPTY       = ENOTEMPTY,
    LFP_ENOTSOCK        = ENOTSOCK,
    LFP_ENOTSUP         = ENOTSUP,
    LFP_ENOTTY          = ENOTTY,
    LFP_ENXIO           = ENXIO,
    LFP_EOPNOTSUPP      = EOPNOTSUPP,
    LFP_EOVERFLOW       = EOVERFLOW,
    LFP_EPERM           = EPERM,
    LFP_EPIPE           = EPIPE,
    LFP_EPROTO          = EPROTO,
    LFP_EPROTONOSUPPORT = EPROTONOSUPPORT,
    LFP_EPROTOTYPE      = EPROTOTYPE,
    LFP_ERANGE          = ERANGE,
    LFP_EROFS           = EROFS,
#if defined(ESHUTDOWN)
    LFP_ESHUTDOWN       = ESHUTDOWN,
#endif
    LFP_ESPIPE          = ESPIPE,
    LFP_ESRCH           = ESRCH,
    LFP_ESTALE          = ESTALE,
    LFP_ETIME           = ETIME,
    LFP_ETIMEDOUT       = ETIMEDOUT,
    LFP_ETXTBSY         = ETXTBSY,
    LFP_EWOULDBLOCK     = EWOULDBLOCK,
    LFP_EXDEV           = EXDEV,
    LFP_EBUG            = 10000
} lfp_errno_t;



#include <inttypes.h>
#include <unistd.h>
#include <fcntl.h>

typedef uint64_t lfp_open_flags_t;

#if !defined(O_CLOEXEC)
// Syscalls use "int" for passing flags, and since
// *nix systems use the LP64 data model, "int" is 32 bits
// which means that we can allocate unsupported flags in the
// upper part of an lfp_open_flags_t value
# define O_CLOEXEC ( 1 << 32 )
#endif

int lfp_pipe (int pipefd[2], lfp_open_flags_t flags);



#include <sys/select.h>

int lfp_select(int nfds, fd_set *readfds, fd_set *writefds,
               fd_set *exceptfds, const struct timespec *timeout,
               const sigset_t *sigmask);

void lfp_fd_clr(int fd, fd_set *set);

bool lfp_fd_isset(int fd, fd_set *set);

void lfp_fd_set(int fd, fd_set *set);

void lfp_fd_zero(fd_set *set);



#include <sys/socket.h>

typedef enum {
    LFP_AF_UNIX   = AF_UNIX,
    LFP_AF_LOCAL  = AF_LOCAL,
    LFP_AF_INET   = AF_INET,
    LFP_AF_INET6  = AF_INET6,
#if defined(AF_PACKET)
    LFP_AF_PACKET = AF_PACKET,
#endif
} lfp_socket_domain_t;

typedef enum {
    LFP_SOCK_STREAM    = SOCK_STREAM,
    LFP_SOCK_DGRAM     = SOCK_DGRAM,
#if defined(SOCK_SEQPACKET)
    LFP_SOCK_SEQPACKET = SOCK_SEQPACKET,
#endif
#if defined(SOCK_RDM)
    LFP_SOCK_RDM       = SOCK_RDM,
#endif
#if defined(SOCK_RAW)
    LFP_SOCK_RAW       = SOCK_RAW,
#endif
} lfp_socket_type_t;

int lfp_socket(lfp_socket_domain_t domain,
               lfp_socket_type_t   type,
               int                 protocol,
               lfp_open_flags_t    flags);

int lfp_accept(int              sockfd,
               struct sockaddr  *addr,
               socklen_t        *addrlen,
               lfp_open_flags_t flags);

struct cmsghdr* lfp_cmsg_firsthdr (struct msghdr* msgh);

struct cmsghdr* lfp_cmsg_nxthdr (struct msghdr* msgh, struct cmsghdr* cmsg);

size_t lfp_cmsg_align (size_t length);

size_t lfp_cmsg_space (size_t length);

size_t lfp_cmsg_len (size_t length);

void* lfp_cmsg_data (struct cmsghdr* cmsg);



int lfp_set_fd_cloexec(int fd);

int lfp_set_fd_nonblock(int fd);



#include <errno.h>

int lfp_errno (void);

int lfp_set_errno (int value);



#include <sys/wait.h>

typedef enum {
    LFP_WNOHANG    = WNOHANG,
    LFP_WUNTRACED  = WUNTRACED,
    LFP_WCONTINUED = WCONTINUED,
} lfp_wait_option_t;

bool lfp_wifexited (int status);

int lfp_wexitstatus (int status);

bool lfp_wifsignaled (int status);

int lfp_wtermsig (int status);

int lfp_wcoredump (int status);

bool lfp_wifstopped (int status);

int lfp_wstopsig (int status);

bool lfp_wifcontinued (int status);



typedef struct {
    struct lfp_spawn_action *actions;
} lfp_spawn_file_actions_t;

int lfp_spawn_file_actions_init(lfp_spawn_file_actions_t *file_actions);

int lfp_spawn_file_actions_destroy(lfp_spawn_file_actions_t *file_actions);

int lfp_spawn_file_actions_addopen(lfp_spawn_file_actions_t *file_actions,
                                   int fd, const char *path,
                                   lfp_open_flags_t oflags, mode_t mode);

int lfp_spawn_file_actions_addclose(lfp_spawn_file_actions_t *file_actions,
                                    int fd);

int lfp_spawn_file_actions_adddup2(lfp_spawn_file_actions_t *file_actions,
                                   int fd, int newfd);

typedef struct {
    uint32_t flags;
    pid_t    pgroup;
    uid_t    uid;
    gid_t    gid;
    sigset_t sigdefault;
    sigset_t sigmask;
} lfp_spawnattr_t;

typedef enum {
    LFP_SPAWN_RESETIDS      = 1 << 0,
    LFP_SPAWN_SETUGID       = 1 << 1,
    LFP_SPAWN_SETPGROUP     = 1 << 2,
    LFP_SPAWN_SETSIGMASK    = 1 << 3,
    LFP_SPAWN_SETSIGDEFAULT = 1 << 4
} lfp_spawnattr_flags;

int lfp_spawnattr_init(lfp_spawnattr_t *attr);
int lfp_spawnattr_destroy(lfp_spawnattr_t *attr);

int lfp_spawnattr_getflags(lfp_spawnattr_t *attr, uint32_t *flags);
int lfp_spawnattr_setflags(lfp_spawnattr_t *attr, const uint32_t flags);

int lfp_spawnattr_getpgroup(lfp_spawnattr_t *attr, pid_t *pgroup);
int lfp_spawnattr_setpgroup(lfp_spawnattr_t *attr, const pid_t pgroup);

int lfp_spawnattr_getsigmask(lfp_spawnattr_t *attr, sigset_t *sigmask);
int lfp_spawnattr_setsigmask(lfp_spawnattr_t *attr, const sigset_t *sigmask);

int lfp_spawnattr_getsigdefault(lfp_spawnattr_t *attr, sigset_t *sigdefault);
int lfp_spawnattr_setsigdefault(lfp_spawnattr_t *attr, const sigset_t *sigdefault);

int lfp_spawnattr_getugid(lfp_spawnattr_t *attr, uid_t *uid, gid_t *gid);
int lfp_spawnattr_setugid(lfp_spawnattr_t *attr, const uid_t uid, const gid_t gid);

int lfp_spawn(pid_t *pid,
              const char *path,
              char *const argv[],
              char *const envp[],
              const lfp_spawn_file_actions_t *file_actions,
              const lfp_spawnattr_t *attr,
              bool search);



#include <signal.h>

sighandler_t lfp_sig_ign (void);

sighandler_t lfp_sig_dfl (void);

sighandler_t lfp_sig_err (void);

typedef enum {
  LFP_SIG_BLOCK   = SIG_BLOCK,
  LFP_SIG_UNBLOCK = SIG_UNBLOCK,
  LFP_SIG_SETMASK = SIG_SETMASK
} lfp_sigmask_how_t;

// NSIG is nowhere in POSIX, so some systems might not have it
// Linux and FreeBSD do, and that's enough for the moment
typedef enum {
#if defined(NSIG)
  LFP_NSIG = NSIG,
#else
# error "Cannot determing number of signals"
#endif
  LFP_SIGHUP    = SIGHUP,
  LFP_SIGQUIT   = SIGQUIT,
  LFP_SIGTRAP   = SIGTRAP,
#if defined(SIGEMT)
  LFP_SIGEMT    = SIGEMT,
#endif
  LFP_SIGKILL   = SIGKILL,
  LFP_SIGBUS    = SIGBUS,
  LFP_SIGSYS    = SIGSYS,
  LFP_SIGPIPE   = SIGPIPE,
  LFP_SIGALRM   = SIGALRM,
  LFP_SIGURG    = SIGURG,
  LFP_SIGSTOP   = SIGSTOP,
  LFP_SIGTSTP   = SIGTSTP,
  LFP_SIGCONT   = SIGCONT,
  LFP_SIGCHLD   = SIGCHLD,
  LFP_SIGCLD    = SIGCLD,
  LFP_SIGTTIN   = SIGTTIN,
  LFP_SIGTTOU   = SIGTTOU,
  LFP_SIGIO     = SIGIO,
  LFP_SIGXCPU   = SIGXCPU,
  LFP_SIGXFSZ   = SIGXFSZ,
  LFP_SIGVTALRM = SIGVTALRM,
  LFP_SIGPROF   = SIGPROF,
  LFP_SIGWINCH  = SIGWINCH,
#if defined(SIGINFO)
  LFP_SIGINFO   = SIGINFO,
#endif
  LFP_SIGUSR1   = SIGUSR1,
  LFP_SIGUSR2   = SIGUSR2
} lfp_signal_t;

int lfp_sigrtmin (void);

int lfp_sigrtmax (void);

typedef enum {
  LFP_SA_NOCLDSTOP = SA_NOCLDSTOP,
  LFP_SA_NOCLDWAIT = SA_NOCLDWAIT,
  LFP_SA_NODEFER   = SA_NODEFER,
  LFP_SA_ONSTACK   = SA_ONSTACK,
  LFP_SA_RESETHAND = SA_RESETHAND,
  LFP_SA_RESTART   = SA_RESTART,
  LFP_SA_SIGINFO   = SA_SIGINFO
} lfp_sigaction_flag_t;

typedef enum {
  LFP_SI_USER     = SI_USER,
  LFP_SI_KERNEL   = SI_KERNEL,
  LFP_SI_QUEUE    = SI_QUEUE,
  LFP_SI_TIMER    = SI_TIMER,
  LFP_SI_MESGQ    = SI_MESGQ,
  LFP_SI_ASYNCIO  = SI_ASYNCIO,
  LFP_SI_SIGIO    = SI_SIGIO,
  LFP_SI_TKILL    = SI_TKILL,
  LFP_ILL_ILLOPC  = ILL_ILLOPC,
  LFP_ILL_ILLOPN  = ILL_ILLOPN,
  LFP_ILL_ILLADR  = ILL_ILLADR,
  LFP_ILL_ILLTRP  = ILL_ILLTRP,
  LFP_ILL_PRVOPC  = ILL_PRVOPC,
  LFP_ILL_PRVREG  = ILL_PRVREG,
  LFP_ILL_COPROC  = ILL_COPROC,
  LFP_ILL_BADSTK  = ILL_BADSTK,
  LFP_FPE_INTDIV  = FPE_INTDIV,
  LFP_FPE_INTOVF  = FPE_INTOVF,
  LFP_FPE_FLTDIV  = FPE_FLTDIV,
  LFP_FPE_FLTOVF  = FPE_FLTOVF,
  LFP_FPE_FLTUND  = FPE_FLTUND,
  LFP_FPE_FLTRES  = FPE_FLTRES,
  LFP_FPE_FLTINV  = FPE_FLTINV,
  LFP_FPE_FLTSUB  = FPE_FLTSUB,
  LFP_SEGV_MAPERR = SEGV_MAPERR,
  LFP_SEGV_ACCERR = SEGV_ACCERR,
  LFP_BUS_ADRALN  = BUS_ADRALN,
  LFP_BUS_ADRERR  = BUS_ADRERR,
  LFP_BUS_OBJERR  = BUS_OBJERR,
  LFP_TRAP_BRKPT  = TRAP_BRKPT,
  LFP_TRAP_TRACE  = TRAP_TRACE
} lfp_si_code_t;



#if defined(__linux__)
# if @HAVE_EMULATED_SIGNALFD@ // HAVE_EMULATED_SIGNALFD
struct signalfd_siginfo { unsigned int ssi_signo; };
# else
#  include <sys/signalfd.h>
# endif
#endif

int lfp_install_signalfd(int signum, int sa_flags, bool* blockp);

int lfp_uninstall_signalfd(int signum, bool block);

#endif // _LIBFIXPOSIX_H_
