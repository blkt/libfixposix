#if !defined(_LIBFIXPOSIX_H_)
# define _LIBFIXPOSIX_H_

#include <stdlib.h>
#include <stdbool.h>



#include <inttypes.h>

typedef uint64_t lfp_flags_t;

#include <errno.h>

typedef enum {
    LFP_E2BIG = E2BIG,
    LFP_EACCES = EACCES,
    LFP_EADDRINUSE = EADDRINUSE,
    LFP_EADDRNOTAVAIL = EADDRNOTAVAIL,
    LFP_EAFNOSUPPORT = EAFNOSUPPORT,
    LFP_EAGAIN = EAGAIN,
    LFP_EALREADY = EALREADY,
    LFP_EBADF = EBADF,
    LFP_EBADMSG = EBADMSG,
    LFP_EBUSY = EBUSY,
    LFP_ECANCELED = ECANCELED,
    LFP_ECHILD = ECHILD,
    LFP_ECONNABORTED = ECONNABORTED,
    LFP_ECONNREFUSED = ECONNREFUSED,
    LFP_ECONNRESET = ECONNRESET,
    LFP_EDEADLK = EDEADLK,
    LFP_EDESTADDRREQ = EDESTADDRREQ,
    LFP_EDOM = EDOM,
    LFP_EDQUOT = EDQUOT,
    LFP_EEXIST = EEXIST,
    LFP_EFAULT = EFAULT,
    LFP_EFBIG = EFBIG,
    LFP_EHOSTUNREACH = EHOSTUNREACH,
    LFP_EIDRM = EIDRM,
    LFP_EILSEQ = EILSEQ,
    LFP_EINPROGRESS = EINPROGRESS,
    LFP_EINTR = EINTR,
    LFP_EINVAL = EINVAL,
    LFP_EIO = EIO,
    LFP_EISCONN = EISCONN,
    LFP_EISDIR = EISDIR,
    LFP_ELOOP = ELOOP,
    LFP_EMFILE = EMFILE,
    LFP_EMLINK = EMLINK,
    LFP_EMSGSIZE = EMSGSIZE,
    LFP_EMULTIHOP = EMULTIHOP,
    LFP_ENAMETOOLONG = ENAMETOOLONG,
    LFP_ENETDOWN = ENETDOWN,
    LFP_ENETRESET = ENETRESET,
    LFP_ENETUNREACH = ENETUNREACH,
    LFP_ENFILE = ENFILE,
    LFP_ENOBUFS = ENOBUFS,
    LFP_ENODATA = ENODATA,
    LFP_ENODEV = ENODEV,
    LFP_ENOENT = ENOENT,
    LFP_ENOEXEC = ENOEXEC,
    LFP_ENOLCK = ENOLCK,
    LFP_ENOLINK = ENOLINK,
    LFP_ENOMEM = ENOMEM,
    LFP_ENOMSG = ENOMSG,
    LFP_ENOPROTOOPT = ENOPROTOOPT,
    LFP_ENOSPC = ENOSPC,
    LFP_ENOSR = ENOSR,
    LFP_ENOSTR = ENOSTR,
    LFP_ENOSYS = ENOSYS,
    LFP_ENOTCONN = ENOTCONN,
    LFP_ENOTDIR = ENOTDIR,
    LFP_ENOTEMPTY = ENOTEMPTY,
    LFP_ENOTSOCK = ENOTSOCK,
    LFP_ENOTSUP = ENOTSUP,
    LFP_ENOTTY = ENOTTY,
    LFP_ENXIO = ENXIO,
    LFP_EOPNOTSUPP = EOPNOTSUPP,
    LFP_EOVERFLOW = EOVERFLOW,
    LFP_EPERM = EPERM,
    LFP_EPIPE = EPIPE,
    LFP_EPROTO = EPROTO,
    LFP_EPROTONOSUPPORT = EPROTONOSUPPORT,
    LFP_EPROTOTYPE = EPROTOTYPE,
    LFP_ERANGE = ERANGE,
    LFP_EROFS = EROFS,
    LFP_ESPIPE = ESPIPE,
    LFP_ESRCH = ESRCH,
    LFP_ESTALE = ESTALE,
    LFP_ETIME = ETIME,
    LFP_ETIMEDOUT = ETIMEDOUT,
    LFP_ETXTBSY = ETXTBSY,
    LFP_EWOULDBLOCK = EWOULDBLOCK,
    LFP_EXDEV = EXDEV,
} lfp_errno_t;



#include <unistd.h>
#include <fcntl.h>

#if !defined(O_CLOEXEC)
// Syscalls use "int" for passing flags, and since
// *nix systems use the LP64 data model, "int" is 32 bits
// which means that we can allocate unsupported flags in the
// upper part of an lfp_flags_t value
# define O_CLOEXEC ( 1 >> 32 )
#endif

int lfp_pipe (int pipefd[2], lfp_flags_t flags);



#include <sys/select.h>

int lfp_select(int nfds, fd_set *readfds, fd_set *writefds,
               fd_set *exceptfds, const struct timespec *timeout,
               const sigset_t *sigmask);

void lfp_fd_clr(int fd, fd_set *set);

bool lfp_fd_isset(int fd, fd_set *set);

void lfp_fd_set(int fd, fd_set *set);

void lfp_fd_zero(fd_set *set);



#include <sys/socket.h>

typedef enum {
    LFP_AF_UNIX = AF_UNIX,
    LFP_AF_LOCAL = AF_LOCAL,
    LFP_AF_INET = AF_INET,
    LFP_AF_INET6 = AF_INET6,
#if defined(AF_PACKET)
    LFP_AF_PACKET = AF_PACKET,
#endif
} lfp_socket_domain_t;

typedef enum {
    LFP_SOCK_STREAM = SOCK_STREAM,
    LFP_SOCK_DGRAM = SOCK_DGRAM,
#if defined(SOCK_SEQPACKET)
    LFP_SOCK_SEQPACKET = SOCK_SEQPACKET,
#endif
#if defined(SOCK_RDM)
    LFP_SOCK_RDM = SOCK_RDM,
#endif
#if defined(SOCK_RAW)
    LFP_SOCK_RAW = SOCK_RAW,
#endif
} lfp_socket_type_t;

int lfp_socket(lfp_socket_domain_t domain,
               lfp_socket_type_t   type,
               int                 protocol,
               lfp_flags_t         flags);

int lfp_accept(int             sockfd,
               struct sockaddr *addr,
               socklen_t       *addrlen,
               lfp_flags_t     flags);

struct cmsghdr* lfp_cmsg_firsthdr (struct msghdr* msgh);

struct cmsghdr* lfp_cmsg_nxthdr (struct msghdr* msgh, struct cmsghdr* cmsg);

size_t lfp_cmsg_align (size_t length);

size_t lfp_cmsg_space (size_t length);

size_t lfp_cmsg_len (size_t length);

void* lfp_cmsg_data (struct cmsghdr* cmsg);



int lfp_set_fd_cloexec(int fd);

int lfp_set_fd_nonblock(int fd);



#include <errno.h>

int lfp_errno (void);

int lfp_set_errno (int value);



#include <sys/wait.h>

typedef enum {
    LFP_WNOHANG = WNOHANG,
    LFP_WUNTRACED = WUNTRACED,
    LFP_WCONTINUED = WCONTINUED,
    LFP_WNOWAIT = WNOWAIT
} lfp_wait_option_t;

bool lfp_wifexited (int status);

int lfp_wexitstatus (int status);

bool lfp_wifsignaled (int status);

int lfp_wtermsig (int status);

int lfp_wcoredump (int status);

bool lfp_wifstopped (int status);

int lfp_wstopsig (int status);

bool lfp_wifcontinued (int status);



typedef struct {
} lfp_spawn_file_actions_t;

typedef struct {
} lfp_spawnattr_t;

int lfp_spawn(pid_t *pid,
              const char *path,
              const lfp_spawn_file_actions_t *file_actions,
              const lfp_spawnattr_t *attrp,
              char *const argv[],
              char *const envp[]);

int lfp_spawnp(pid_t *pid,
               const char *file,
               const lfp_spawn_file_actions_t *file_actions,
               const lfp_spawnattr_t *attrp,
               char *const argv[],
               char *const envp[]);



/* signal.c */

#include <signal.h>

sighandler_t lfp_sig_ign (void);

sighandler_t lfp_sig_dfl (void);

sighandler_t lfp_sig_err (void);

typedef enum {
  LFP_SIG_BLOCK = SIG_BLOCK,
  LFP_SIG_UNBLOCK = SIG_UNBLOCK,
  LFP_SIG_SETMASK = SIG_SETMASK
} lfp_sigmask_how_t;

typedef enum {
  LFP_NSIG = NSIG,
  LFP_SIGHUP = SIGHUP,
  LFP_SIGQUIT = SIGQUIT,
  LFP_SIGTRAP = SIGTRAP,
  LFP_SIGEMT =
    #ifdef SIGEMT
      SIGEMT
    #else
      0
    #endif
,
  LFP_SIGKILL = SIGKILL,
  LFP_SIGBUS = SIGBUS,
  LFP_SIGSYS = SIGSYS,
  LFP_SIGPIPE = SIGPIPE,
  LFP_SIGALRM = SIGALRM,
  LFP_SIGURG = SIGURG,
  LFP_SIGSTOP = SIGSTOP,
  LFP_SIGTSTP = SIGTSTP,
  LFP_SIGCONT = SIGCONT,
  LFP_SIGCHLD = SIGCHLD,
  LFP_SIGCLD = SIGCLD,
  LFP_SIGTTIN = SIGTTIN,
  LFP_SIGTTOU = SIGTTOU,
  LFP_SIGIO = SIGIO,
  LFP_SIGXCPU = SIGXCPU,
  LFP_SIGXFSZ = SIGXFSZ,
  LFP_SIGVTALRM = SIGVTALRM,
  LFP_SIGPROF = SIGPROF,
  LFP_SIGWINCH = SIGWINCH,
  LFP_SIGINFO =
    #ifdef SIGINFO
      SIGINFO
    #else
      0
    #endif
,
  LFP_SIGUSR1 = SIGUSR1,
  LFP_SIGUSR2 = SIGUSR2
} lfp_signal_number_t;

int lfp_sigrtmin (void);

int lfp_sigrtmax (void);

typedef enum {
  LFP_SA_NOCLDSTOP = SA_NOCLDSTOP,
  LFP_SA_NOCLDWAIT = SA_NOCLDWAIT,
  LFP_SA_NODEFER = SA_NODEFER,
  LFP_SA_ONSTACK = SA_ONSTACK,
  LFP_SA_RESETHAND = SA_RESETHAND,
  LFP_SA_RESTART = SA_RESTART,
  LFP_SA_SIGINFO = SA_SIGINFO
} lfp_sigaction_flag_t;

typedef enum {
  LFP_SI_USER = SI_USER,
  LFP_SI_KERNEL = SI_KERNEL,
  LFP_SI_QUEUE = SI_QUEUE,
  LFP_SI_TIMER = SI_TIMER,
  LFP_SI_MESGQ = SI_MESGQ,
  LFP_SI_ASYNCIO = SI_ASYNCIO,
  LFP_SI_SIGIO = SI_SIGIO,
  LFP_SI_TKILL = SI_TKILL,
  LFP_ILL_ILLOPC = ILL_ILLOPC,
  LFP_ILL_ILLOPN = ILL_ILLOPN,
  LFP_ILL_ILLADR = ILL_ILLADR,
  LFP_ILL_ILLTRP = ILL_ILLTRP,
  LFP_ILL_PRVOPC = ILL_PRVOPC,
  LFP_ILL_PRVREG = ILL_PRVREG,
  LFP_ILL_COPROC = ILL_COPROC,
  LFP_ILL_BADSTK = ILL_BADSTK,
  LFP_FPE_INTDIV = FPE_INTDIV,
  LFP_FPE_INTOVF = FPE_INTOVF,
  LFP_FPE_FLTDIV = FPE_FLTDIV,
  LFP_FPE_FLTOVF = FPE_FLTOVF,
  LFP_FPE_FLTUND = FPE_FLTUND,
  LFP_FPE_FLTRES = FPE_FLTRES,
  LFP_FPE_FLTINV = FPE_FLTINV,
  LFP_FPE_FLTSUB = FPE_FLTSUB,
  LFP_SEGV_MAPERR = SEGV_MAPERR,
  LFP_SEGV_ACCERR = SEGV_ACCERR,
  LFP_BUS_ADRALN = BUS_ADRALN,
  LFP_BUS_ADRERR = BUS_ADRERR,
  LFP_BUS_OBJERR = BUS_OBJERR,
  LFP_TRAP_BRKPT = TRAP_BRKPT,
  LFP_TRAP_TRACE = TRAP_TRACE
} lfp_si_code_t;



#if defined(__linux__)
# if @HAVE_EMULATED_SIGNALFD@ // HAVE_EMULATED_SIGNALFD
struct signalfd_siginfo { unsigned int ssi_signo; };
# else
#  include <sys/signalfd.h>
# endif
#endif

int lfp_install_signalfd(int signum, int sa_flags, bool* blockp);

int lfp_uninstall_signalfd(int signum, bool block);

#endif // _LIBFIXPOSIX_H_
