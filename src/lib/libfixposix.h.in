#if !defined(_LIBFIXPOSIX_H_)
# define _LIBFIXPOSIX_H_

#if defined(__cplusplus)
extern "C" {
#endif

#include <stdlib.h>
#include <stdbool.h>

int lfp_mkstemp(char *tmplate);



#include <errno.h>

#define EBUG 10000



int lfp_strerror(int errnum, char *buf, size_t buflen);

size_t lfp_strnlen(const char *s, size_t maxlen);



#include <inttypes.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

extern char **environ;

typedef uint64_t lfp_open_flags_t;

#if !defined(O_CLOEXEC)
// Syscalls use "int" for passing flags, and since
// *nix systems use the LP64 data model, "int" is 32 bits
// which means that we can allocate unsupported flags in the
// upper part of an lfp_open_flags_t value
# define O_CLOEXEC ( 1ULL << 32 )
#endif

int lfp_open(const char *pathname, lfp_open_flags_t flags, ...);

int lfp_creat(const char *pathname, mode_t mode);

int lfp_pipe(int pipefd[2], lfp_open_flags_t flags);

int lfp_is_fd_cloexec(int fd);

int lfp_set_fd_cloexec(int fd, bool enabled);

int lfp_is_fd_nonblock(int fd);

int lfp_set_fd_nonblock(int fd, bool enabled);

int lfp_truncate(const char *path, off_t length);

int lfp_ftruncate(int fd, off_t length);

ssize_t lfp_pread(int fd, void *buf, size_t count, off_t offset);

ssize_t lfp_pwrite(int fd, const void *buf, size_t count, off_t offset);

off_t lfp_lseek(int fd, off_t offset, int whence);

int lfp_stat(const char *path, struct stat *buf);

int lfp_fstat(int fd, struct stat *buf);

int lfp_lstat(const char *path, struct stat *buf);

int lfp_fd_is_open(int fd);

bool lfp_isreg(mode_t mode);

bool lfp_isdir(mode_t mode);

bool lfp_ischr(mode_t mode);

bool lfp_isblk(mode_t mode);

bool lfp_isfifo(mode_t mode);

bool lfp_islnk(mode_t mode);

bool lfp_issock(mode_t mode);

char* lfp_getpath(char *const envp[]);

int lfp_execve(const char *path, char *const argv[], char *const envp[])
    __attribute__((nonnull (1)));

int lfp_execvpe(const char *file, char *const argv[], char *const envp[])
    __attribute__((nonnull (1)));



#include <sys/mman.h>

void *lfp_mmap(void *addr, size_t length, int prot,
               int flags, int fd, off_t offset);

int lfp_munmap(void *addr, size_t length);



#include <sys/select.h>

int lfp_select(int nfds, fd_set *readfds, fd_set *writefds,
               fd_set *exceptfds, const struct timespec *timeout,
               const sigset_t *sigmask);

void lfp_fd_clr(int fd, fd_set *set);

bool lfp_fd_isset(int fd, fd_set *set);

void lfp_fd_set(int fd, fd_set *set);

void lfp_fd_zero(fd_set *set);



#include <sys/socket.h>

int lfp_socket(int              domain,
               int              type,
               int              protocol,
               lfp_open_flags_t flags);

int lfp_accept(int              sockfd,
               struct sockaddr  *addr,
               socklen_t        *addrlen,
               lfp_open_flags_t flags);

struct cmsghdr* lfp_cmsg_firsthdr(struct msghdr* msgh);

struct cmsghdr* lfp_cmsg_nxthdr(struct msghdr* msgh, struct cmsghdr* cmsg);

size_t lfp_cmsg_space(size_t length);

size_t lfp_cmsg_len(size_t length);

void* lfp_cmsg_data(struct cmsghdr* cmsg);



#include <errno.h>

int lfp_errno(void);

int lfp_set_errno(int value);



#include <sys/wait.h>

bool lfp_wifexited(int status);

int lfp_wexitstatus(int status);

bool lfp_wifsignaled(int status);

int lfp_wtermsig(int status);

int lfp_wcoredump(int status);

bool lfp_wifstopped(int status);

int lfp_wstopsig(int status);

bool lfp_wifcontinued(int status);



typedef struct {
    int initialized;
    int allocated;
    struct lfp_spawn_action *actions;
} lfp_spawn_file_actions_t;

int lfp_spawn_file_actions_init(lfp_spawn_file_actions_t *file_actions);

int lfp_spawn_file_actions_destroy(lfp_spawn_file_actions_t *file_actions);

int lfp_spawn_file_actions_addopen(lfp_spawn_file_actions_t *file_actions,
                                   int fd, const char *path,
                                   lfp_open_flags_t oflags, mode_t mode);

int lfp_spawn_file_actions_addclose(lfp_spawn_file_actions_t *file_actions,
                                    int fd);

int lfp_spawn_file_actions_adddup2(lfp_spawn_file_actions_t *file_actions,
                                   int fd, int newfd);

typedef struct {
    uint32_t flags;
    pid_t    pgroup;
    uid_t    uid;
    gid_t    gid;
    sigset_t sigdefault;
    sigset_t sigmask;
} lfp_spawnattr_t;

typedef enum {
        LFP_SPAWN_RESETIDS      = 1 << 0,
#define LFP_SPAWN_RESETIDS      ( 1 << 0 )
        LFP_SPAWN_SETUGID       = 1 << 1,
#define LFP_SPAWN_SETUGID       ( 1 << 1 )
        LFP_SPAWN_SETPGROUP     = 1 << 2,
#define LFP_SPAWN_SETPGROUP     ( 1 << 2 )
        LFP_SPAWN_SETSIGMASK    = 1 << 3,
#define LFP_SPAWN_SETSIGMASK    ( 1 << 3 )
        LFP_SPAWN_SETSIGDEFAULT = 1 << 4
#define LFP_SPAWN_SETSIGDEFAULT ( 1 << 4 )
} lfp_spawnattr_flags;

int lfp_spawnattr_init(lfp_spawnattr_t *attr);
int lfp_spawnattr_destroy(lfp_spawnattr_t *attr);

int lfp_spawnattr_getflags(lfp_spawnattr_t *attr, uint32_t *flags);
int lfp_spawnattr_setflags(lfp_spawnattr_t *attr, const uint32_t flags);

int lfp_spawnattr_getpgroup(lfp_spawnattr_t *attr, pid_t *pgroup);
int lfp_spawnattr_setpgroup(lfp_spawnattr_t *attr, const pid_t pgroup);

int lfp_spawnattr_getsigmask(lfp_spawnattr_t *attr, sigset_t *sigmask);
int lfp_spawnattr_setsigmask(lfp_spawnattr_t *attr, const sigset_t *sigmask);

int lfp_spawnattr_getsigdefault(lfp_spawnattr_t *attr, sigset_t *sigdefault);
int lfp_spawnattr_setsigdefault(lfp_spawnattr_t *attr, const sigset_t *sigdefault);

int lfp_spawnattr_getugid(lfp_spawnattr_t *attr, uid_t *uid, gid_t *gid);
int lfp_spawnattr_setugid(lfp_spawnattr_t *attr, const uid_t uid, const gid_t gid);

int lfp_spawn(pid_t *pid,
              const char *path,
              char *const argv[],
              char *const envp[],
              const lfp_spawn_file_actions_t *file_actions,
              const lfp_spawnattr_t *attr);

int lfp_spawnp(pid_t *pid,
               const char *file,
               char *const argv[],
               char *const envp[],
               const lfp_spawn_file_actions_t *file_actions,
               const lfp_spawnattr_t *attr);



#include <signal.h>

typedef void (*lfp_sighandler_t) (int);

lfp_sighandler_t lfp_sig_dfl(void);

lfp_sighandler_t lfp_sig_err(void);

lfp_sighandler_t lfp_sig_hold(void);

lfp_sighandler_t lfp_sig_ign(void);

// FIXME: inline NSIG
// NSIG is nowhere in POSIX, so some systems might not have it
// Linux and FreeBSD do, and that's enough for the moment
#if defined(NSIG)
#define LFP_NSIG NSIG
#else
# error "Cannot determine number of signals"
#endif

int lfp_sigrtmin(void);

int lfp_sigrtmax(void);



#if defined(__linux__)
# if @HAVE_EMULATED_SIGNALFD@ // HAVE_EMULATED_SIGNALFD
struct signalfd_siginfo { unsigned int ssi_signo; };
# else
#  include <sys/signalfd.h>
# endif
#endif

int lfp_install_signalfd(int signum, int sa_flags, bool* blockp);

int lfp_uninstall_signalfd(int signum, bool block);



#include <dirent.h>

int lfp_readdir(DIR *dirp, struct dirent *entry, struct dirent **result);



#include <sys/resource.h>

int lfp_getrlimit(int resource, struct rlimit *rlim);

int lfp_setrlimit(int resource, const struct rlimit *rlim);

#ifdef __cplusplus
}
#endif

#endif // _LIBFIXPOSIX_H_
